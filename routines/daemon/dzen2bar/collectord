#!/usr/bin/env perl
# A Durchlauferhitzer that deploys various info scraper processes and listens for their output. Offers a single connector to receive && process data, if needed, before forwarding it to dzen2.
use v5.36.0;
use strict;
use warnings;
use lib './lib';
use Cwd 'abs_path';
use POSIX qw(strftime WNOHANG);
use Carp;
use Daemon;
use File::Basename;
use constant TASKS => abs_path('./tasks');

$SIG{TERM} = $SIG{INT} = \&reaper;

my %CURRENT_STATE;
my @ORDER = ('local_time', 'cpu_stats', 'memory_stats');
@CURRENT_STATE{@ORDER} = ('') x @ORDER;

my $DAEMON = run_producer_consumer_pipeline();

STDOUT->autoflush(1);
undef @ARGV;
sleep 5;
while (<>) {
    s/^\[(.*?)\]\s*\r?\n?// and do {
        chomp;
        croak "Misconfiguration, tag '$1' not a supported input filter."
            unless exists $CURRENT_STATE{$1};
        next if $_ eq $CURRENT_STATE{$1};
        $CURRENT_STATE{$1} = $_;
        say (join ' | ', grep { /.+/ } @CURRENT_STATE{@ORDER});
    }
}

sub reaper {
    $DAEMON->childproc_reaper;
    exit 0;
}

sub run_producer_consumer_pipeline() {
    my @producers = glob TASKS . '/*.pl';
    pipe my $collector_reader, my $collector_writer 
        or die "Failed to create collector pipe: $!";
    pipe my $dzen2_reader, my $dzen2_writer
        or die "Failed to create dzen2 pipe: $!";
    
    my $collector = Daemon->is_myself({
            cmd => undef,
            src => $collector_reader,
            sink => $dzen2_writer,
            is_leader => 1,
            uid => 'collectord',
        })->with_child('dzen2', {
                cmd => ['dzen2', '-bg', '#213555', '-fn', "DejaVu Sans Mono-12"], 
                src => $dzen2_reader,
    });
    open my $null_in, '<', '/dev/null' or die "Cannot open /dev/null for reading: $!";
    for (@producers) {
        my $id = fileparse($_, qr/\..*/);
        $collector->with_child($id, {
                    cmd => ['perl', $_, $id],
                    src => $null_in,
                    sink => $collector_writer
        });
    }
    return $collector->dispatch;
}

